/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright Â© 2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
"use client";
import { getter as _, mapTree as N, extendDataItem as B, Keys as O, hasRelativeStackingContext as M } from "@progress/kendo-react-common";
import { TABLE_PREVENT_SELECTION_ELEMENT as F, TABLE_ROW_INDEX_ATTRIBUTE as G, TABLE_COL_INDEX_ATTRIBUTE as U } from "./constants.mjs";
const X = "items", x = {}, b = (e, t) => !e || Array.isArray(e) && e.length === 0 ? [t] : e.findIndex((o) => o === t) > -1 ? e.filter((o) => o !== t) : [...e, t], J = (e) => {
  let t = e;
  for (; t; ) {
    if (t.hasAttribute(F))
      return !0;
    t = t.parentElement;
  }
  return !1;
}, A = (e, t) => {
  let n = e;
  for (; n; ) {
    if (n.tagName === t)
      return n;
    if (n.tagName === "TABLE")
      return null;
    n = n.parentElement;
  }
  return null;
}, k = (e) => {
  if (!e)
    return;
  const t = e.getAttribute(G);
  return t ? parseInt(t, 10) : void 0;
}, V = (e) => {
  if (!e)
    return;
  const t = e.getAttribute(U);
  return t ? parseInt(t, 10) : void 0;
}, Q = (e) => {
  const t = e.subItemsField || X, n = _(e.dataItemKey);
  return N(
    e.data,
    t,
    (o) => B(o, t, {
      [e.selectedField]: e.selectedState[n(o)]
    })
  );
}, Y = (e) => {
  const { event: t, dataItemKey: n, selectedState: o } = e, { syntheticEvent: c, nativeEvent: r, dataItems: E, componentId: a, mode: T, cell: f, selectedField: w } = t, { target: g, ctrlKey: p, metaKey: C, altKey: I, shiftKey: D } = r;
  if (c.isDefaultPrevented() || r.keyCode !== O.enter)
    return o;
  const y = A(g, "TD"), i = A(g, "TR"), s = V(y), m = k(i);
  let d = {};
  return y && i && m !== void 0 && s !== void 0 && (d = H({
    selectedState: o,
    dataItemKey: n,
    event: {
      ctrlKey: p,
      metaKey: C,
      altKey: I,
      shiftKey: D,
      dataItems: E,
      cell: f,
      mode: T,
      selectedField: w,
      componentId: a,
      startColIndex: s,
      endColIndex: s,
      startRowIndex: m,
      endRowIndex: m,
      isDrag: !1,
      syntheticEvent: c,
      nativeEvent: r,
      target: t.target,
      dataItem: null
    }
  })), d;
}, H = (e) => {
  const { event: t, dataItemKey: n, selectedState: o } = e, {
    dataItems: c,
    startRowIndex: r,
    endRowIndex: E,
    startColIndex: a,
    endColIndex: T,
    cell: f,
    isDrag: w,
    ctrlKey: g,
    shiftKey: p,
    metaKey: C,
    componentId: I,
    mode: D,
    dataItem: y
  } = t, i = _(n);
  let s = {};
  const m = y !== null;
  if (D === "single") {
    const d = c.slice(r, r + 1)[0], u = i(d);
    x[I] = {
      rowIndex: r,
      colIndex: a
    }, s[u] = f ? [a] : !0;
  } else if (w || !p && !g && !C && !m) {
    w || (x[I] = {
      rowIndex: r,
      colIndex: a
    });
    const d = [];
    for (let l = a; l <= T; l++)
      d.push(l);
    c.slice(r, E + 1).forEach((l) => {
      const h = i(l);
      s[h] = f ? [...d] : !0;
    });
  } else if (g || C || m) {
    x[I] = {
      rowIndex: r,
      colIndex: a
    };
    const u = c.slice(r, E + 1)[0], l = i(u);
    s = { ...o }, s[l] = f && !m ? b(s[l], a) : !s[l];
  } else if (p) {
    const d = x[I] && x[I].rowIndex || 0, u = x[I] && x[I].colIndex || 0, l = Math.min(d, r, E), h = Math.max(d, r, E), v = Math.min(u, a, T), K = Math.max(u, a, T), R = [];
    for (let S = v; S <= K; S++)
      R.push(S);
    c.slice(l, h + 1).forEach((S) => {
      const L = i(S);
      s[L] = f ? [...R] : !0;
    });
  }
  return s;
}, W = M(), Z = (e) => {
  if (!e || !W)
    return null;
  let t = e.parentElement;
  for (; t; ) {
    if (window.getComputedStyle(t).transform !== "none")
      return t;
    t = t.parentElement;
  }
}, $ = (e) => {
  if (e && e.ownerDocument && e !== e.ownerDocument.body) {
    const t = e.getBoundingClientRect();
    return {
      left: t.left - e.scrollLeft,
      top: t.top - e.scrollTop
    };
  }
  return { left: 0, top: 0 };
}, P = (e) => {
  const t = e ? typeof e.enabled == "boolean" ? e.enabled : !0 : !1, n = e ? !!e.drag : !1, o = e && e.mode ? e.mode : "multiple", c = !!(e && e.cell);
  return { enabled: t, drag: n, mode: o, cell: c };
};
export {
  A as closestTagName,
  V as getColumnIndex,
  $ as getOffset,
  k as getRowIndex,
  H as getSelectedState,
  Y as getSelectedStateFromKeyDown,
  P as getSelectionOptions,
  J as isInNonSelectable,
  Z as relativeContextElement,
  Q as setSelectedState
};
