/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright Â© 2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
"use client";
import * as t from "react";
import e from "prop-types";
import { createPropsContext as ne, usePropsContext as se, useCustomComponent as E, useId as oe, useDir as le, useIsomorphicLayoutEffect as ie, dispatchEvent as v, getTabIndex as ue, classNames as de, kendoThemeMaps as z } from "@progress/kendo-react-common";
const ce = ne(), y = t.forwardRef((M, O) => {
  const s = se(ce, M), {
    size: u,
    rounded: d,
    fillMode: h,
    prefix: S = void 0,
    suffix: w = void 0,
    ariaDescribedBy: A,
    ariaLabelledBy: N,
    autoSize: H,
    className: F,
    defaultValue: R,
    disabled: r,
    readOnly: $,
    required: c,
    rows: D,
    id: L,
    name: q,
    placeholder: j,
    style: K,
    tabIndex: G,
    value: f,
    valid: C,
    validationMessage: k,
    validityStyles: P,
    onChange: m,
    onFocus: p,
    onBlur: b,
    // Removed to support direct use in Form Field component
    visited: me,
    touched: pe,
    modified: be,
    ...J
  } = s, a = t.useRef(null), I = t.useCallback(
    () => {
      a.current && a.current.focus();
    },
    []
  ), [T, V] = t.useState(R), [Q, U] = E(S), [W, X] = E(w), o = f !== void 0, l = o ? f : T, i = t.useCallback(
    () => ({
      element: a,
      focus: I,
      get value() {
        return l;
      },
      get name() {
        return a.current && a.current.name;
      }
    }),
    [I, l]
  );
  t.useImperativeHandle(O, i);
  const [Y, B] = t.useState("auto"), Z = oe(), _ = le(a, s.dir), x = C !== void 0 ? C : c ? !!l : !0;
  t.useEffect(
    () => {
      a.current && a.current.setCustomValidity && a.current.setCustomValidity(
        x ? "" : k || ""
      );
    },
    [x, k]
  ), ie(
    () => {
      a.current && B(`${a.current.scrollHeight}px`);
    },
    [l]
  );
  const ee = t.useCallback(
    (n) => {
      const g = n.target.value;
      B("auto"), !o && !r && V(g), m && !r && v(
        m,
        n,
        {
          ...i(),
          value: g
        },
        { value: g }
      );
    },
    [V, m, r, o]
  ), te = t.useCallback(
    (n) => {
      p && !r && v(
        p,
        n,
        i(),
        void 0
      );
    },
    [p, r]
  ), ae = t.useCallback(
    (n) => {
      b && !r && v(
        b,
        n,
        i(),
        void 0
      );
    },
    [b, r]
  ), re = {
    id: L || Z,
    role: "textbox",
    name: q,
    className: "k-input-inner !k-overflow-auto",
    ref: a,
    disabled: r,
    rows: D,
    placeholder: j,
    readOnly: $,
    required: c,
    tabIndex: ue(G, r),
    style: H ? { resize: "none", overflow: "hidden", height: Y } : {},
    "aria-labelledby": N,
    "aria-describedby": A,
    "aria-multiline": !0,
    "aria-disabled": r || void 0,
    value: o ? f : T,
    ...J,
    onChange: ee,
    onFocus: te,
    onBlur: ae
  };
  return /* @__PURE__ */ t.createElement(
    "span",
    {
      className: de(
        "k-input",
        "k-textarea",
        {
          [`k-input-${z.sizeMap[u] || u}`]: u,
          [`k-input-${h}`]: h,
          [`k-rounded-${z.roundedMap[d] || d}`]: d,
          "k-invalid": !(x || P !== void 0 || P === !0),
          "k-required": c,
          "k-disabled": r
        },
        F
      ),
      style: K,
      dir: _
    },
    s.prefix && /* @__PURE__ */ t.createElement(Q, { ...U }),
    /* @__PURE__ */ t.createElement("textarea", { ...re }),
    s.suffix && /* @__PURE__ */ t.createElement(W, { ...X })
  );
});
y.propTypes = {
  ariaDescribedBy: e.string,
  ariaLabelledBy: e.string,
  autoSize: e.bool,
  className: e.string,
  defaultValue: e.string,
  dir: e.string,
  disabled: e.bool,
  readOnly: e.bool,
  rows: e.number,
  id: e.string,
  name: e.string,
  placeholder: e.string,
  style: e.object,
  tabIndex: e.number,
  value: e.oneOfType([
    e.string,
    e.arrayOf(e.string),
    e.number
  ]),
  onChange: e.func,
  onFocus: e.func,
  onBlur: e.func,
  size: e.oneOf([null, "small", "medium", "large"]),
  rounded: e.oneOf([null, "small", "medium", "large", "full"]),
  fillMode: e.oneOf([null, "solid", "flat", "outline"])
};
const fe = {
  size: "medium",
  rounded: "medium",
  fillMode: "solid"
};
y.displayName = "KendoTextArea";
y.defaultProps = fe;
export {
  y as TextArea,
  ce as TextAreaPropsContext
};
