/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright Â© 2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
"use client";
import * as a from "react";
import D from "prop-types";
import { createPropsContext as W, validatePackage as Y, usePropsContext as _, useDir as j, Keys as v, useDraggable as F, classNames as J, getTabIndex as z } from "@progress/kendo-react-common";
import { sliderDragTitle as R, messages as P } from "../messages/index.mjs";
import { useLocalization as Q } from "@progress/kendo-react-intl";
import { RANGE_ACTION as n, rangeReducer as U } from "./range-raducer.mjs";
import { packageMetadata as Z } from "../package-metadata.mjs";
const ee = (r, l, e) => {
  const [s, i] = a.useState(r), d = a.useCallback(
    (u) => {
      const x = U(l.state || s, { ...u, ...l });
      e && e(x, u.event), i(x);
    },
    [l, e]
  );
  return [s, d];
}, te = W(), T = a.forwardRef((r, l) => {
  Y(Z);
  const e = _(te, r), s = a.useRef(null), i = a.useRef(null), d = a.useRef(null), u = a.useRef(null), x = a.useRef(null), V = a.useCallback(
    () => {
      u.current && u.current.focus();
    },
    [u]
  );
  a.useImperativeHandle(s, () => ({
    element: i.current,
    focus: V,
    props: e
  })), a.useImperativeHandle(l, () => s.current);
  const f = a.useMemo(
    () => e.min,
    [e.min]
  ), k = a.useMemo(
    () => e.max,
    [e.max]
  ), K = a.useMemo(
    () => e.step !== void 0 ? e.step : $.step,
    [e.step, $.step]
  ), p = j(i, e.dir), A = (t, m) => {
    e.onChange && s.current && e.onChange.call(void 0, {
      value: t,
      target: s.current,
      syntheticEvent: m
    });
  }, [E, S] = a.useState(""), [b, c] = ee(
    e.defaultValue || $.defaultValue,
    {
      min: f,
      max: k,
      step: K,
      state: e.value
    },
    A
  ), o = a.useMemo(
    () => e.value || b,
    [e.value, b]
  ), H = a.useRef(null), w = a.useRef(null), y = a.useMemo(
    () => (o.start - f) / (k - f) * 100,
    [o.start, f, k]
  ), g = a.useMemo(
    () => (o.end - f) / (k - f) * 100,
    [o.end, f, k]
  ), L = a.useMemo(
    () => e.vertical ? { paddingTop: 0, height: "100%" } : {},
    [e.vertical]
  ), N = a.useMemo(
    () => e.vertical ? { marginTop: "0.5rem", marginBottom: "0.5rem" } : { marginLeft: "0.5rem", marginRight: "0.5rem" },
    [e.vertical]
  ), M = Q(), I = a.useCallback(
    (t) => {
      if (!w.current)
        return;
      const m = w.current.getBoundingClientRect(), h = e.vertical ? m.bottom - t.clientY : p === "rtl" ? m.right - t.clientX : t.clientX - m.left, C = e.vertical ? m.height : m.width, X = h / C;
      return f + X * (k - f);
    },
    [
      w,
      e.vertical,
      p,
      f,
      k,
      b.start,
      b.end,
      e.value && e.value.start,
      e.value && e.value.end
    ]
  ), q = a.useCallback(
    (t) => t <= o.start ? "start" : t >= o.end ? "end" : 2 * t < o.end + o.start ? "start" : "end",
    [
      b.start,
      b.end,
      e.value && e.value.start,
      e.value && e.value.end
    ]
  ), B = a.useCallback(
    (t) => {
      switch (t.keyCode) {
        case v.right:
          t.preventDefault(), c({ type: p === "rtl" ? n.decrease : n.increase, key: "start", event: t });
          break;
        case v.up:
          t.preventDefault(), c({ type: n.increase, key: "start", event: t });
          break;
        case v.left:
          t.preventDefault(), c({ type: p === "rtl" ? n.increase : n.decrease, key: "start", event: t });
          break;
        case v.down:
          t.preventDefault(), c({ type: n.decrease, key: "start", event: t });
          break;
        case v.home:
          t.preventDefault(), c({ type: n.min, key: "start", event: t });
          break;
        case v.end:
          t.preventDefault(), c({ type: n.max, key: "start", event: t });
          break;
      }
    },
    [c]
  ), G = a.useCallback(
    (t) => {
      switch (t.keyCode) {
        case v.right:
          t.preventDefault(), c({ type: p === "rtl" ? n.decrease : n.increase, key: "end", event: t });
          break;
        case v.up:
          t.preventDefault(), c({ type: n.increase, key: "end", event: t });
          break;
        case v.left:
          t.preventDefault(), c({ type: p === "rtl" ? n.increase : n.decrease, key: "end", event: t });
          break;
        case v.down:
          t.preventDefault(), c({ type: n.decrease, key: "end", event: t });
          break;
        case v.home:
          t.preventDefault(), c({ type: n.min, key: "end", event: t });
          break;
        case v.end:
          t.preventDefault(), c({ type: n.max, key: "end", event: t });
          break;
      }
    },
    [c, p]
  ), O = a.useCallback(
    (t) => {
      const m = I(t), h = q(m);
      S(h), h === "end" ? x.current.focus() : u.current.focus();
      const C = h === "end" ? n.end : n.start;
      c({ type: C, payload: m, event: t });
    },
    [e.vertical, f, k, c]
  );
  return F(w, { onPress: O, onDrag: (t) => {
    const m = I(t), h = E === "end" ? n.end : n.start;
    c({ type: h, payload: m, event: t });
  }, onRelease: (t) => {
    const m = I(t), h = E === "end" ? n.end : n.start;
    c({ type: h, payload: m, event: t }), S("");
  } }), /* @__PURE__ */ a.createElement(
    "div",
    {
      id: e.id,
      style: e.style,
      ref: i,
      dir: p,
      className: J(
        "k-slider",
        {
          "k-rtl": p === "rtl",
          "k-disabled": e.disabled,
          "k-slider-vertical": e.vertical,
          "k-slider-horizontal": !e.vertical
        },
        e.className
      )
    },
    /* @__PURE__ */ a.createElement(
      "div",
      {
        ref: w,
        className: "k-slider-track-wrap",
        style: {
          flexGrow: 1,
          position: "relative",
          touchAction: "none",
          ...N
        }
      },
      e.children && /* @__PURE__ */ a.createElement(
        "ul",
        {
          className: "k-reset k-slider-items",
          style: { ...L }
        },
        a.Children.map(e.children, (t) => t && a.cloneElement(
          t,
          {
            position: 100 * (t.props.position - e.min) / (e.max - e.min),
            vertical: e.vertical
          },
          t.props.children
        ))
      ),
      /* @__PURE__ */ a.createElement(
        "div",
        {
          ref: H,
          className: "k-slider-track",
          style: e.vertical ? { bottom: 0, height: "100%" } : { [p === "rtl" ? "right" : "left"]: 0, width: "100%" }
        },
        y !== null && g !== null && /* @__PURE__ */ a.createElement(
          "div",
          {
            "data-selection": !0,
            ref: d,
            title: `${o.start} - ${o.end}`,
            className: "k-slider-selection",
            style: e.vertical ? { height: g - y + "%", bottom: y + "%" } : {
              [p === "rtl" ? "right" : "left"]: y + "%",
              width: g - y + "%"
            }
          }
        ),
        /* @__PURE__ */ a.createElement(
          "span",
          {
            ref: u,
            role: "slider",
            tabIndex: z(e.startTabIndex, e.disabled, void 0),
            "aria-valuemin": f,
            "aria-valuemax": Math.max(k, o.end),
            "aria-valuenow": o.start,
            "aria-disabled": e.disabled ? "true" : void 0,
            "aria-valuetext": `${o.start} - ${o.end}`,
            className: "k-draghandle",
            title: M.toLanguageString(R, P[R]),
            style: e.vertical ? { bottom: "calc(" + y + "%)", zIndex: 1 } : p === "rtl" ? { right: "calc(" + y + "% - 13px)", zIndex: 1 } : { left: "calc(" + y + "%)", zIndex: 1 },
            onKeyDown: B
          }
        ),
        /* @__PURE__ */ a.createElement(
          "span",
          {
            ref: x,
            role: "slider",
            tabIndex: z(e.endTabIndex, e.disabled, void 0),
            "aria-valuemin": Math.min(f, o.start),
            "aria-valuemax": k,
            "aria-valuenow": o.end,
            "aria-disabled": e.disabled ? "true" : void 0,
            "aria-valuetext": `${o.start} - ${o.end}`,
            className: "k-draghandle",
            title: M.toLanguageString(R, P[R]),
            style: e.vertical ? { bottom: "calc(" + g + "%)", zIndex: 1 } : p === "rtl" ? { right: "calc(" + g + "% - 13px)", zIndex: 1 } : { left: "calc(" + g + "%)", zIndex: 1 },
            onKeyDown: G
          }
        )
      )
    )
  );
}), ae = {
  value: (r, l, e) => {
    if (r.value) {
      const s = r.value.start, i = r.value.end, d = r.min, u = r.max;
      if (s > i || s > u || s < d || i > u || i < d || i < s)
        return new Error(
          `Invalid prop + ${l} supplied to ${e}.
                    The { start, end } value must be between the min & max value and { start, end } must be start < end.
                    `
        );
    }
    return null;
  },
  defaultValue: (r, l, e) => {
    if (r.defaultValue) {
      const s = r.defaultValue.start, i = r.defaultValue.end, d = r.min, u = r.max;
      if (s > i || s > u || s < d || i > u || i < d || i < s)
        return new Error(
          `Invalid prop + ${l} supplied to ${e}.
                    The { start, end } value must be between the min & max value and { start, end } must be start < end.
                    `
        );
    }
    return null;
  },
  onChange: D.func,
  step: D.number,
  min: (r, l, e) => {
    const s = r[l], i = r.min, d = r.max;
    return i === void 0 ? new Error(
      `Invalid prop + ${l} supplied to ${e}.
                ${l} value can not be undefined.
                `
    ) : s && i >= d ? new Error(
      `Invalid prop + ${l} supplied to ${e}.
                ${l} value can not be equal to or bigger than the max value.
                `
    ) : null;
  },
  max: (r, l, e) => {
    const s = r[l], i = r.min, d = r.max;
    return d === void 0 ? new Error(
      `Invalid prop + ${l} supplied to ${e}.
                ${l} value can not be undefined.
                `
    ) : s && d <= i ? new Error(
      `Invalid prop + ${l} supplied to ${e}.
                ${l} value can not be equal to or smaller than the min value.
                `
    ) : null;
  },
  vertical: D.bool,
  disabled: D.bool,
  dir: D.oneOf(["ltr", "rtl"])
}, $ = {
  step: 1,
  defaultValue: {
    start: 0,
    end: 0
  },
  vertical: !1,
  disabled: !1
};
T.displayName = "KendoReactRangeSlider";
T.propTypes = ae;
T.defaultProps = $;
export {
  T as RangeSlider,
  te as RangeSliderPropsContext
};
