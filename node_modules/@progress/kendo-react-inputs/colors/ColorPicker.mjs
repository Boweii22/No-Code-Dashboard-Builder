/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright Â© 2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
"use client";
import * as e from "react";
import n from "prop-types";
import { createPropsContext as se, validatePackage as ce, usePropsContext as ue, Keys as p, useDir as de, classNames as h, kendoThemeMaps as O, getTabIndex as pe, IconWrap as fe, svgIconPropType as me } from "@progress/kendo-react-common";
import { packageMetadata as ke } from "../package-metadata.mjs";
import { Picker as be } from "./Picker.mjs";
import { ColorGradient as ve } from "./ColorGradient.mjs";
import { ColorPalette as ge, DEFAULT_PRESET as Ee, DEFAULT_TILE_SIZE as Ce } from "./ColorPalette.mjs";
import { Button as ye } from "@progress/kendo-react-buttons";
import { caretAltDownIcon as Te } from "@progress/kendo-svg-icons";
import { colorPickerDropdownButtonAriaLabel as z, messages as Se } from "../messages/index.mjs";
import { useLocalization as Pe } from "@progress/kendo-react-intl";
const we = {
  opacity: !0
}, Ie = {
  palette: Ee,
  tileSize: Ce
}, L = (b) => b !== void 0, De = se(), A = e.forwardRef((b, M) => {
  ce(ke);
  const o = ue(De, b), V = Pe(), {
    size: v = k.size,
    rounded: g = k.rounded,
    fillMode: x = k.fillMode,
    popupSettings: _,
    gradientSettings: K,
    paletteSettings: G,
    valid: U,
    disabled: E,
    tabIndex: $,
    view: f,
    icon: C,
    svgIcon: y,
    iconClassName: m,
    onChange: T,
    onFocus: S,
    onBlur: P,
    onActiveColorClick: w,
    className: W
  } = o, a = e.useRef(null), I = e.useRef(null), D = e.useRef(null), c = e.useRef(), Z = e.useRef(null), [j, B] = e.useState(!1), [q, J] = e.useState(o.defaultValue), [Q, X] = e.useState(!1), N = L(o.value), i = L(o.open), l = N ? o.value : q, u = i ? o.open : Q, F = e.useCallback(
    () => {
      a.current && a.current.focus();
    },
    []
  );
  e.useImperativeHandle(M, () => ({
    // we agreed that each element will have focus method exposed
    element: a.current,
    actionElement: Z.current,
    value: l,
    focus: F
  }), [l, F]);
  const s = e.useCallback(
    (t, d) => {
      i || (!t && !d && a && a.current && a.current.focus(), X(t));
    },
    [i]
  ), Y = e.useCallback(
    (t) => {
      const { altKey: d, keyCode: r } = t;
      if (r === p.esc) {
        s(!1);
        return;
      }
      if (r === p.enter && !i) {
        t.preventDefault(), t.stopPropagation(), s(!u);
        return;
      }
      d && (r === p.up || r === p.down) && (t.preventDefault(), t.stopPropagation(), r === p.up && a && a.current && (a.current.focus(), s(!1)), r === p.down && s(!0));
    },
    [u, i]
  ), ee = e.useCallback(
    () => {
      i || (I.current ? I.current.focus() : D.current && D.current.focus());
    },
    [i]
  ), te = e.useCallback(
    () => {
      s(!u, !0);
    },
    [u]
  ), ne = e.useCallback(
    (t) => {
      w && w.call(void 0, {
        syntheticEvent: t,
        nativeEvent: t.nativeEvent,
        value: l
      });
    },
    [w, l]
  ), oe = e.useCallback(
    (t) => {
      c.current ? (clearTimeout(c.current), c.current = void 0) : B(!0), S && S.call(void 0, {
        nativeEvent: t.nativeEvent,
        syntheticEvent: t
      });
    },
    [S]
  ), ae = e.useCallback(
    () => {
      s(!1, !0), B(!1), c.current = void 0;
    },
    []
  ), re = e.useCallback(
    (t) => {
      clearTimeout(c.current), c.current = window.setTimeout(ae), P && P.call(void 0, {
        nativeEvent: t.nativeEvent,
        syntheticEvent: t
      });
    },
    [P]
  ), R = e.useCallback(
    (t, d) => {
      const r = d ? t.rgbaValue : t.value;
      N || J(r), d && s(!1), T && T.call(void 0, {
        value: r,
        nativeEvent: t.nativeEvent,
        syntheticEvent: t.syntheticEvent
      });
    },
    [N, T]
  ), le = e.useCallback(
    (t) => R(t, !0),
    [L, R]
  ), H = de(a, o.dir), ie = U !== !1;
  return /* @__PURE__ */ e.createElement(
    "span",
    {
      id: o.id,
      role: "combobox",
      "aria-label": o.ariaLabel,
      "aria-labelledby": o.ariaLabelledBy,
      "aria-describedby": o.ariaDescribedBy,
      "aria-haspopup": "dialog",
      "aria-expanded": u,
      "aria-disabled": E ? "true" : void 0,
      className: h(
        "k-colorpicker",
        "k-picker",
        "k-icon-picker",
        {
          [`k-picker-${O.sizeMap[v] || v}`]: v,
          [`k-picker-${x}`]: x,
          [`k-rounded-${O.roundedMap[g] || g}`]: g,
          "k-invalid": !ie,
          "k-disabled": E,
          "k-focus": j,
          className: W
        }
      ),
      ref: a,
      tabIndex: pe($, E),
      title: o.title,
      onKeyDown: Y,
      onFocus: oe,
      onBlur: re,
      dir: H
    },
    /* @__PURE__ */ e.createElement(
      be,
      {
        dir: H,
        open: u,
        onOpen: ee,
        popupAnchor: a.current || void 0,
        popupSettings: { ..._ },
        input: /* @__PURE__ */ e.createElement("span", { onClick: ne, className: "k-input-inner" }, /* @__PURE__ */ e.createElement(
          "span",
          {
            className: h(
              "k-value-icon",
              "k-color-preview",
              {
                "k-no-color": !l,
                "k-icon-color-preview": C || y || m
              }
            )
          },
          m && /* @__PURE__ */ e.createElement("span", { className: h("k-color-preview-icon", m) }),
          !m && (C || y) && /* @__PURE__ */ e.createElement(fe, { name: C, icon: y }),
          /* @__PURE__ */ e.createElement("span", { className: "k-color-preview-mask", style: { backgroundColor: l } })
        )),
        button: /* @__PURE__ */ e.createElement(
          ye,
          {
            tabIndex: -1,
            type: "button",
            onClick: te,
            className: "k-input-button",
            rounded: null,
            icon: "caret-alt-down",
            svgIcon: Te,
            "aria-label": V.toLanguageString(z, Se[z])
          }
        ),
        content: /* @__PURE__ */ e.createElement(e.Fragment, null, (f === "combo" || f === "gradient") && /* @__PURE__ */ e.createElement(
          ve,
          {
            ...K,
            tabIndex: 0,
            ref: I,
            value: l,
            onChange: R
          }
        ), (f === "combo" || f === "palette") && /* @__PURE__ */ e.createElement(
          ge,
          {
            ...G,
            ref: D,
            value: l,
            onChange: le
          }
        ))
      }
    )
  );
});
A.propTypes = {
  value: n.string,
  defaultValue: n.string,
  disabled: n.bool,
  view: n.oneOf(["gradient", "palette", "combo"]),
  dir: n.string,
  id: n.string,
  icon: n.string,
  svgIcon: me,
  ariaLabelledBy: n.string,
  ariaDescribedBy: n.string,
  size: n.oneOf([null, "small", "medium", "large"]),
  rounded: n.oneOf([null, "small", "medium", "large", "full"]),
  fillMode: n.oneOf([null, "solid", "flat", "outline"]),
  className: n.string
};
const k = {
  size: "medium",
  rounded: "medium",
  fillMode: "solid",
  view: "palette",
  gradientSettings: we,
  paletteSettings: Ie
};
A.defaultProps = k;
A.displayName = "KendoColorPicker";
export {
  A as ColorPicker,
  De as ColorPickerPropsContext
};
