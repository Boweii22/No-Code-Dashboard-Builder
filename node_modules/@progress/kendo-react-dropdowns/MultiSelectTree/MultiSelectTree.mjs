/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright Â© 2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
"use client";
import * as t from "react";
import a from "prop-types";
import { createPropsContext as at, usePropsContext as it, validatePackage as ot, useId as rt, getTabIndex as lt, useRtl as st, canUseDOM as ct, noop as Z, Keys as r, classNames as ee, IconWrap as ut, kendoThemeMaps as dt } from "@progress/kendo-react-common";
import { Popup as pt } from "@progress/kendo-react-popup";
import { useLocalization as ft } from "@progress/kendo-react-intl";
import { TreeView as Te } from "@progress/kendo-react-treeview";
import { packageMetadata as mt } from "../package-metadata.mjs";
import { getItemValue as gt, areSame as vt, matchTags as De } from "../common/utils.mjs";
import { useDropdownWidth as ht } from "../DropDownTree/useDropdownWidth.mjs";
import { ListNoData as bt } from "../DropDownTree/ListNoData.mjs";
import { nodata as te, messages as ne, adaptiveModeFooterCancel as Re, adaptiveModeFooterApply as Me } from "../messages/index.mjs";
import { FloatingLabel as yt } from "@progress/kendo-react-labels";
import Ct from "../MultiSelect/TagList.mjs";
import Et from "../common/ClearButton.mjs";
import Ne from "../common/ListFilter.mjs";
import { AdaptiveMode as kt } from "../common/AdaptiveMode.mjs";
import { ActionSheetContent as Ft } from "@progress/kendo-react-layout";
import { MOBILE_MEDIUM_DEVISE as xt } from "../common/constants.mjs";
const It = "Please select a value from the list!", { sizeMap: Pe, roundedMap: wt } = dt, St = (O) => O.split("_").map((R) => parseInt(R, 10)), Tt = (O, R) => {
  const { validationMessage: n, valid: K, required: F } = O;
  return {
    customError: n !== void 0,
    valid: !!(K !== void 0 ? K : !F || R),
    valueMissing: !R
  };
}, D = {
  checkField: "checkField",
  checkIndeterminateField: "checkIndeterminateField",
  subItemsField: "items",
  popupSettings: {
    animate: !0,
    width: "200px",
    height: "200px"
  },
  size: "medium",
  rounded: "medium",
  fillMode: "solid",
  required: !1,
  validityStyles: !0
}, Dt = at(), de = t.forwardRef((O, R) => {
  const n = it(Dt, O);
  ot(mt);
  const K = rt(), F = n.id || K, {
    data: q = [],
    dataItemKey: x,
    popupSettings: M = {},
    style: B = {},
    opened: I,
    disabled: C,
    onOpen: ae = Z,
    onClose: A = Z,
    placeholder: pe,
    label: L,
    name: Oe,
    checkField: fe = D.checkField,
    checkIndeterminateField: me = D.checkIndeterminateField,
    subItemsField: ge = D.subItemsField,
    validationMessage: W,
    valid: Be,
    tags: ve,
    value: m,
    required: he = D.required,
    validityStyles: Le = D.validityStyles
  } = n, z = lt(n.tabIndex, C), l = t.useRef(null), y = t.useRef(null), w = t.useRef(null), ie = t.useRef(null), _ = t.useRef(null), E = t.useRef(null), $ = t.useRef(!1), H = t.useRef([]), G = t.useRef(null), [N, Ve] = t.useState(), [Ke, be] = t.useState(!1), [d, oe] = t.useState(!1), [re, qe] = t.useState(), [Ae, We] = t.useState([]), [ye, ze] = t.useState(""), P = !!(re && re <= xt && n.adaptive), s = I !== void 0 ? I : Ke, le = !!(Array.isArray(m) && m.length), se = Tt({ validationMessage: W, valid: Be, required: he }, le), S = st(y, n.dir), _e = {
    width: ht(y, D, M, B),
    ...S !== void 0 ? { direction: S } : {}
  }, $e = t.useCallback(() => y.current && y.current.focus(), []);
  H.current = ve === void 0 ? (m || []).map((e) => ({ text: gt(e, n.textField), data: [e] })) : [...ve], t.useImperativeHandle(
    l,
    () => ({
      props: n,
      element: y.current,
      focus: $e
    })
  ), t.useImperativeHandle(R, () => l.current);
  const He = t.useCallback(
    () => {
      _.current && _.current.setCustomValidity && _.current.setCustomValidity(
        se.valid ? "" : W === void 0 ? It : W
      );
    },
    [W, se]
  );
  t.useEffect(He), t.useEffect(() => {
    const e = ct && window.ResizeObserver && new window.ResizeObserver(tt.bind(void 0));
    return document != null && document.body && e && e.observe(document.body), () => {
      e && e.disconnect();
    };
  }, []), t.useEffect(
    () => {
      G.current && s && G.current.setPosition(G.current._popup);
    },
    [m, s]
  );
  const k = t.useCallback(
    (e, i, o) => {
      if (n.onChange) {
        const b = {
          items: i,
          operation: o,
          ...e
        };
        n.onChange.call(void 0, b);
      }
    },
    [n.onChange]
  ), U = t.useCallback(
    (e) => {
      if (vt(e.item, m, x) || !l.current)
        return;
      const { item: i, nativeEvent: o, syntheticEvent: b } = e, T = {
        syntheticEvent: b,
        nativeEvent: o,
        target: l.current
      };
      k(T, [i], "toggle");
    },
    [m, x, k]
  ), j = t.useCallback(
    (e) => {
      if (!s) {
        if (ae) {
          const i = { ...e };
          ae.call(void 0, i);
        }
        I === void 0 && (be(!0), We(m || []), P && setTimeout(() => {
          var i;
          u((i = ie.current) == null ? void 0 : i.element);
        }, 300));
      }
    },
    [s, I, ae, P, ie]
  ), g = t.useCallback(
    (e) => {
      if (s) {
        if (A) {
          const i = { ...e };
          A.call(void 0, i);
        }
        I === void 0 && be(!1);
      }
    },
    [s, I, A]
  ), h = t.useCallback(
    (e) => {
      $.current = !0, e(), window.setTimeout(() => $.current = !1, 0);
    },
    []
  ), u = t.useCallback(
    (e) => {
      e && h(() => e.focus());
    },
    [h]
  ), Ge = t.useCallback(
    () => {
      var e;
      !d && s ? g({ target: l.current }) : n.filterable ? u((e = w.current) == null ? void 0 : e.element) : u(E.current && E.current.element);
    },
    [d, s, u, g, n.filterable]
  ), Ue = t.useCallback(
    () => {
      d && u(y.current);
    },
    [d, u]
  ), je = t.useCallback(
    (e) => {
      if (!d && !$.current && (oe(!0), n.onFocus && l.current)) {
        const i = {
          syntheticEvent: e,
          nativeEvent: e.nativeEvent,
          target: l.current
        };
        n.onFocus.call(void 0, i);
      }
    },
    [d, n.onFocus]
  ), Je = t.useCallback(
    (e) => {
      if (d && !$.current && l.current) {
        oe(!1);
        const i = {
          syntheticEvent: e,
          nativeEvent: e.nativeEvent,
          target: l.current
        };
        if (n.onBlur) {
          const o = { ...i };
          n.onBlur.call(void 0, o);
        }
        P || g(i);
      }
    },
    [d, n.onBlur, s, I, A]
  ), Qe = t.useCallback(
    () => {
      d && h(Z);
    },
    [d, h]
  ), Xe = t.useCallback(
    (e) => {
      if (!e.isDefaultPrevented() && l.current) {
        oe(!0);
        const i = {
          syntheticEvent: e,
          nativeEvent: e.nativeEvent,
          target: l.current
        };
        s || j(i);
      }
    },
    [s, j]
  ), Ye = t.useCallback(
    (e) => {
      var Y, Se;
      const { keyCode: i, altKey: o } = e, b = E.current && E.current.element;
      if (!l.current || e.isDefaultPrevented() && ((Y = w.current) == null ? void 0 : Y.element) === e.target)
        return;
      const T = {
        syntheticEvent: e,
        nativeEvent: e.nativeEvent,
        target: l.current
      };
      if (m && m.length > 0 && (i === r.left || i === r.right || i === r.home || i === r.end || i === r.delete)) {
        const c = H.current;
        let p = N ? c.findIndex((nt) => De(nt, N, x)) : -1, f;
        const ue = p !== -1;
        i === r.left ? (ue ? p = Math.max(0, p - 1) : p = c.length - 1, f = c[p]) : i === r.right ? p === c.length - 1 ? f = void 0 : ue && (p = Math.min(c.length - 1, p + 1), f = c[p]) : i === r.home ? f = c[0] : i === r.end ? f = c[c.length - 1] : i === r.delete && ue && k(T, c[p].data, "delete"), f !== N && Ve(f);
      }
      if (s)
        if (i === r.esc || o && i === r.up)
          e.preventDefault(), g(T);
        else if (b && b.querySelector(".k-focus") && (i === r.up || i === r.down || i === r.left || i === r.right || i === r.home || i === r.end)) {
          if (i === r.up && ((Se = w.current) != null && Se.element)) {
            const c = Array.from(b.querySelectorAll(".k-treeview-item")), p = [...c].reverse().find((f) => !!(f && f.querySelector(".k-focus")));
            if (p && c.indexOf(p) === 0)
              return h(() => {
                var f;
                u((f = w.current) == null ? void 0 : f.element);
              });
          }
          h(Z);
        } else
          i === r.down && h(() => {
            var c;
            u(((c = w.current) == null ? void 0 : c.element) || b);
          });
      else
        o && i === r.down && (e.preventDefault(), j(T));
    },
    [s, g, u, h, j, N, x, m, k]
  ), Ce = t.useCallback(
    (e) => {
      const { keyCode: i, altKey: o } = e;
      o || i !== r.up && i !== r.down || (e.preventDefault(), h(
        i === r.up ? () => {
          u(y.current);
        } : () => {
          u(E.current && E.current.element);
        }
      ));
    },
    [u, h]
  ), ce = t.useCallback(
    (e) => {
      if (!l.current)
        return;
      const i = {
        syntheticEvent: e,
        nativeEvent: e.nativeEvent,
        target: l.current
      };
      k(i, [], "clear"), g(i), e.preventDefault();
    },
    [k, g]
  ), Ze = t.useCallback(
    (e, i) => {
      var o;
      g({ target: l.current }), d || u((o = w.current) == null ? void 0 : o.element), k({
        syntheticEvent: i,
        nativeEvent: i.nativeEvent,
        target: l.current
      }, e, "delete");
    },
    [k, g, u, d]
  ), Ee = t.useCallback(
    (e) => {
      if (n.onExpandChange && l.current) {
        const { item: i, itemHierarchicalIndex: o, nativeEvent: b, syntheticEvent: T } = e, Y = {
          level: St(o),
          item: i,
          nativeEvent: b,
          syntheticEvent: T,
          target: l.current
        };
        n.onExpandChange.call(void 0, Y);
      }
    },
    [n.onExpandChange]
  ), ke = t.useCallback(
    (e) => {
      if (n.onFilterChange && l.current) {
        const o = {
          filter: { field: n.textField, operator: "contains", value: e.target.value },
          syntheticEvent: e.syntheticEvent,
          nativeEvent: e.nativeEvent,
          target: l.current
        };
        n.onFilterChange.call(void 0, o), n.filter === void 0 && ze(e.target.value);
      }
    },
    [n.onFilterChange, n.filter, n.textField]
  ), Fe = t.useCallback(
    (e) => {
      if (!l.current)
        return;
      const i = {
        syntheticEvent: e,
        nativeEvent: e.nativeEvent,
        target: l.current
      };
      n.onCancel && n.onCancel.call(void 0, i), g(i), e.preventDefault();
    },
    [n.onCancel, g]
  ), et = () => {
    const e = n.filterable ? /* @__PURE__ */ t.createElement(
      Ne,
      {
        value: n.filter === void 0 ? ye : n.filter,
        ref: ie,
        onChange: ke,
        onKeyDown: Ce,
        size: v,
        rounded: V,
        fillMode: Q
      }
    ) : null, i = {
      adaptiveTitle: n.adaptiveTitle,
      expand: s,
      onClose: (o) => n.onCancel ? Fe(o) : ce(o),
      windowWidth: re,
      mobileFilter: e,
      footer: {
        cancelText: J.toLanguageString(Re, ne[Re]),
        onCancel: (o) => n.onCancel ? Fe(o) : ce(o),
        applyText: J.toLanguageString(Me, ne[Me]),
        onApply: (o) => g(o)
      }
    };
    return /* @__PURE__ */ t.createElement(kt, { ...i }, /* @__PURE__ */ t.createElement(Ft, { className: "!k-overflow-hidden" }, /* @__PURE__ */ t.createElement("div", { className: "k-list-container" }, /* @__PURE__ */ t.createElement("div", { className: "k-list k-list-lg" }, q.length > 0 ? /* @__PURE__ */ t.createElement(
      Te,
      {
        ref: E,
        tabIndex: z,
        data: q,
        focusIdField: x,
        textField: n.textField,
        checkField: fe,
        checkIndeterminateField: me,
        expandField: n.expandField,
        childrenField: ge,
        expandIcons: !0,
        onItemClick: U,
        onCheckChange: U,
        onExpandChange: Ee,
        checkboxes: !0,
        size: v,
        item: n.item,
        dir: S
      }
    ) : /* @__PURE__ */ t.createElement(xe, null, J.toLanguageString(te, ne[te]))))));
  }, tt = t.useCallback(
    (e) => {
      for (let i of e)
        qe(i.target.clientWidth);
    },
    []
  ), xe = n.listNoData || bt, J = ft(), Ie = !Le || se.valid, { size: v, rounded: V, fillMode: Q } = n, X = P && s ? Ae : H.current, we = /* @__PURE__ */ t.createElement(t.Fragment, null, /* @__PURE__ */ t.createElement(
    "span",
    {
      className: ee("k-multiselecttree k-input", n.className, {
        [`k-input-${Pe[v] || v}`]: v,
        [`k-rounded-${wt[V] || V}`]: V,
        [`k-input-${Q}`]: Q,
        "k-focus": d && !C,
        "k-invalid": !Ie,
        "k-disabled": C,
        "k-loading": n.loading,
        "k-required": he
      }),
      tabIndex: z,
      accessKey: n.accessKey,
      id: F,
      style: L ? { ...B, width: void 0 } : B,
      dir: S,
      ref: y,
      onKeyDown: C ? void 0 : Ye,
      onMouseDown: Qe,
      onFocus: je,
      onBlur: Je,
      role: "combobox",
      "aria-haspopup": "tree",
      "aria-expanded": s,
      "aria-disabled": C,
      "aria-label": L,
      "aria-labelledby": n.ariaLabelledBy,
      "aria-describedby": n.ariaDescribedBy ? n.ariaDescribedBy : "tagslist-" + F,
      "aria-required": n.required,
      onClick: C ? void 0 : Xe
    },
    /* @__PURE__ */ t.createElement(
      "div",
      {
        id: "tagslist-" + F,
        className: ee("k-input-values k-chip-list k-selection-multiple", {
          [`k-chip-list-${Pe[v] || v}`]: v
        })
      },
      X.length > 0 && /* @__PURE__ */ t.createElement(
        Ct,
        {
          tag: n.tag,
          onTagDelete: Ze,
          data: X,
          guid: F,
          focused: N ? H.current.find((e) => De(e, N, x)) : void 0,
          size: v
        }
      )
    ),
    /* @__PURE__ */ t.createElement("span", { className: "k-input-inner" }, X.length === 0 && /* @__PURE__ */ t.createElement("span", { className: "k-input-value-text" }, pe)),
    n.loading && /* @__PURE__ */ t.createElement(ut, { className: "k-input-loading-icon", name: "loading" }),
    le && !C && X.length > 0 && /* @__PURE__ */ t.createElement(Et, { onClick: ce }),
    /* @__PURE__ */ t.createElement(
      "select",
      {
        name: Oe,
        ref: _,
        tabIndex: -1,
        "aria-hidden": !0,
        title: L,
        style: { opacity: 0, width: 1, border: 0, zIndex: -1, position: "absolute", left: "50%" }
      },
      /* @__PURE__ */ t.createElement(
        "option",
        {
          value: n.valueMap ? n.valueMap.call(void 0, m) : m
        }
      )
    ),
    !P && /* @__PURE__ */ t.createElement(
      pt,
      {
        ...M,
        popupClass: ee(
          M.popupClass,
          "k-multiselecttree-popup"
        ),
        className: ee(M.className, { "k-rtl": S === "rtl" }),
        style: _e,
        anchor: M.anchor || y.current,
        show: s,
        onOpen: Ge,
        onClose: Ue,
        ref: G
      },
      n.filterable && /* @__PURE__ */ t.createElement(
        Ne,
        {
          value: n.filter === void 0 ? ye : n.filter,
          ref: w,
          onChange: ke,
          onKeyDown: Ce,
          tabIndex: z,
          size: v,
          rounded: V,
          fillMode: Q
        }
      ),
      q.length > 0 ? /* @__PURE__ */ t.createElement(
        Te,
        {
          style: { height: M.height },
          ref: E,
          tabIndex: z,
          data: q,
          focusIdField: x,
          textField: n.textField,
          checkField: fe,
          checkIndeterminateField: me,
          expandField: n.expandField,
          childrenField: ge,
          expandIcons: !0,
          onItemClick: U,
          onCheckChange: U,
          onExpandChange: Ee,
          checkboxes: !0,
          size: v,
          item: n.item,
          dir: S
        }
      ) : /* @__PURE__ */ t.createElement(xe, null, J.toLanguageString(te, ne[te]))
    )
  ), P && et());
  return L ? /* @__PURE__ */ t.createElement(
    yt,
    {
      label: L,
      editorValue: le,
      editorPlaceholder: pe,
      editorValid: Ie,
      editorDisabled: C,
      editorId: F,
      style: { width: B ? B.width : void 0 },
      children: we,
      dir: S
    }
  ) : we;
}), Rt = {
  opened: a.bool,
  disabled: a.bool,
  dir: a.string,
  tabIndex: a.number,
  accessKey: a.string,
  data: a.array,
  value: a.any,
  valueMap: a.func,
  placeholder: a.string,
  dataItemKey: a.string.isRequired,
  textField: a.string.isRequired,
  checkField: a.string,
  checkIndeterminateField: a.string,
  expandField: a.string,
  subItemsField: a.string,
  className: a.string,
  style: a.object,
  label: a.string,
  validationMessage: a.string,
  validityStyles: a.bool,
  valid: a.bool,
  required: a.bool,
  name: a.string,
  id: a.string,
  ariaLabelledBy: a.string,
  ariaDescribedBy: a.string,
  filterable: a.bool,
  filter: a.string,
  loading: a.bool,
  tags: a.arrayOf(a.shape({
    text: a.string,
    data: a.arrayOf(a.any)
  })),
  popupSettings: a.shape({
    animate: a.oneOfType([a.bool, a.shape({
      openDuration: a.number,
      closeDuration: a.number
    })]),
    popupClass: a.string,
    className: a.string,
    appendTo: a.any,
    width: a.oneOfType([a.string, a.number]),
    height: a.oneOfType([a.string, a.number])
  }),
  onOpen: a.func,
  onClose: a.func,
  onFocus: a.func,
  onBlur: a.func,
  onChange: a.func,
  onFilterChange: a.func,
  onExpandChange: a.func,
  onCancel: a.func,
  item: a.func,
  listNoData: a.func,
  adaptiveTitle: a.string,
  adaptive: a.bool
};
de.displayName = "KendoReactMultiSelectTree";
de.defaultProps = D;
de.propTypes = Rt;
export {
  de as MultiSelectTree,
  Dt as MultiSelectTreePropsContext
};
