/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright Â© 2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
"use client";"use strict";Object.defineProperty(exports,Symbol.toStringTag,{value:"Module"});const d=require("react"),g=require("./utils/index.js");function u(a){const t=Object.create(null,{[Symbol.toStringTag]:{value:"Module"}});if(a){for(const e in a)if(e!=="default"){const s=Object.getOwnPropertyDescriptor(a,e);Object.defineProperty(t,e,s.get?s:{enumerable:!0,get:()=>a[e]})}}return t.default=a,Object.freeze(t)}const n=u(d);class S{constructor(t=0,e,s,r){this.total=t,this.offsets=[],this.heights=[];let i=0;for(let h=0;h<t;h++){this.offsets.push(i);const o=r&&r[h].expanded&&r[h].rowType==="data"?s:e;i+=o,this.heights.push(o)}}height(t){return this.heights[t]}index(t){if(t<0)return;const e=this.offsets.reduce((s,r,i)=>{if(s!==void 0)return s;if(r===t)return i;if(r>t)return i-1},void 0);return e===void 0?this.total-1:e}offset(t){return this.offsets[t]}totalHeight(){const t=this.offsets[this.offsets.length-1],e=this.heights[this.heights.length-1];return t+e}}class p{constructor(t){this.table=null,this.containerHeight=0,this.topCacheCount=0,this.attendedSkip=0,this.propsSkip=0,this.total=0,this.scrollableVirtual=!1,this.realSkip=0,this.pageSize=0,this.PageChange=null,this.tableBodyRef=n.createRef(),this.fixedScroll=!1,this.askedSkip=void 0,this.containerRef=n.createRef(),this.tableTransform="",this.scrollSyncing=!1,this.lastLoaded=0,this.firstLoaded=0,this.lastScrollTop=0,this.reactVersion=Number.parseFloat(n.version),this.firstLoaded=this.pageSize,this.lastLoaded=this.realSkip+this.pageSize,this.scrollHandler=this.scrollHandler.bind(this)}get container(){return this.containerRef.current}translate(t,e){this.scrollableVirtual&&this.table&&(g.firefox||this.reactVersion<=17||e?this.table.style.transform="translateY("+t+"px)":this.tableTransform="translateY("+t+"px)")}changePage(t,e){this.PageChange&&this.PageChange({skip:Math.max(0,t),take:this.pageSize},e)}reset(){this.scrollSyncing=!0,!this.fixedScroll&&(this.container&&(this.container.scrollTop=0),this.translate(0,!0))}scrollHandler(t){if(!this.scrollableVirtual||!this.container||!this.table||!this.rowHeightService||!this.containerRef.current)return;if(this.scrollSyncing){this.scrollSyncing=!1;return}const e=this.container.scrollTop,s=this.lastScrollTop>=e,r=!s;this.lastScrollTop=e;let i=this.rowHeightService.index(e),h=this.rowHeightService.offset(i);const{offsetHeight:o}=this.containerRef.current,c=this.rowHeightService.index(e+o);if(r&&c>=this.lastLoaded&&this.lastLoaded<this.total){const l=i+this.pageSize-this.total;l>0&&(i=i-l,h=this.rowHeightService.offset(i)),this.firstLoaded=i,this.translate(h);let f=this.firstLoaded+this.pageSize;this.lastLoaded=Math.min(f,this.total),this.changePage(this.firstLoaded,t)}else if(s&&i<this.firstLoaded){const l=Math.floor(this.pageSize*.3);this.firstLoaded=Math.max(i-l,0),this.translate(this.rowHeightService.offset(this.firstLoaded)),this.lastLoaded=Math.min(this.firstLoaded+this.pageSize,this.total),this.changePage(this.firstLoaded,t)}}}exports.RowHeightService=S;exports.VirtualScrollFixed=p;
