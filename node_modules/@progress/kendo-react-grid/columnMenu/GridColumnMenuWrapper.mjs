/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright Â© 2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
"use client";
import * as t from "react";
import { Popup as R } from "@progress/kendo-react-popup";
import { TABBABLE_ELEMENTS as $, Navigation as x, IconWrap as z, getActiveElement as A, Keys as F } from "@progress/kendo-react-common";
import { filterIcon as L } from "@progress/kendo-svg-icons";
import { columnMenu as w, messages as W } from "../messages/index.mjs";
import { useLocalization as _ } from "@progress/kendo-react-intl";
const H = [
  ".k-columnmenu-item-content",
  ".k-filter-menu-container"
].map((o) => $.map(
  (u) => `${o} ${u}`
)), P = [
  [".k-tabstrip-items"],
  [".k-columnmenu-item"],
  ...H
], Q = (o) => {
  const [u, d] = t.useState(!1), l = t.useRef(null), s = t.useRef(null), c = t.useRef(null), a = t.useRef(0), { columnMenu: E, ...v } = o, { column: h } = o, k = _(), g = h.title || h.field, M = g ? `${g} ` : "", b = "#", p = (e) => {
    const n = A(document);
    clearTimeout(a.current), a.current = window.setTimeout(() => {
      n && e.relatedTarget !== l.current && s.current && !s.current.contains(n) && i();
    });
  }, y = () => {
    clearTimeout(a.current);
  }, C = (e) => {
    e.preventDefault(), u && o.onCloseMenu && o.onCloseMenu(), d(!u);
  }, i = () => {
    o.onCloseMenu && o.onCloseMenu(), d(!1), !o.navigatable && l.current && l.current.focus();
  }, D = (e) => {
    var n;
    if (e.keyCode === F.tab) {
      const r = e.target, f = r && ((n = r.closest(".k-grid")) == null ? void 0 : n.getElementsByClassName("k-grid-content")[0]);
      f && f.scrollWidth > f.clientWidth && r.scrollIntoView({ inline: "center" });
    }
  }, m = t.useMemo(() => o.show !== void 0 ? o.show : u, [o.show, u]), T = (e) => {
    var n;
    (n = c.current) == null || n.triggerKeyboardEvent(e);
  }, S = (e) => {
    var n;
    (n = c.current) == null || n.triggerMouseEvent(e);
  }, K = (e, n, r) => {
    r.preventDefault(), r.shiftKey ? n.focusPrevious(e) : n.focusNext(e);
  }, B = (e, n, r) => {
    e && e.click();
  }, I = (e, n, r) => {
    r.preventDefault(), i();
  }, N = (e, n, r) => {
    r.preventDefault(), n.focusElement(e);
  };
  return t.useEffect(() => (m && s.current && (c.current = new x({
    tabIndex: 0,
    root: s,
    selectors: P,
    keyboardEvents: {
      keydown: {
        Tab: K,
        Enter: B,
        Escape: I
      }
    },
    mouseEvents: {
      mousedown: N
    }
  }), c.current.focusElement(c.current.first, null)), () => {
    c.current && (c.current = null);
  }), [m]), /* @__PURE__ */ t.createElement(t.Fragment, null, /* @__PURE__ */ t.createElement(
    "a",
    {
      className: "k-grid-header-menu k-grid-column-menu",
      ref: l,
      onClick: C,
      onKeyDown: D,
      href: b,
      tabIndex: o.navigatable ? -1 : void 0,
      "aria-label": `${M}${k.toLanguageString(w, W[w])}`
    },
    /* @__PURE__ */ t.createElement(z, { name: "filter", icon: L })
  ), /* @__PURE__ */ t.createElement(
    R,
    {
      anchor: l.current,
      show: m,
      popupClass: "k-column-menu k-column-menu-popup k-grid-columnmenu-popup"
    },
    /* @__PURE__ */ t.createElement(
      "div",
      {
        ref: s,
        onBlur: p,
        onFocus: y,
        onMouseDown: S,
        onKeyDown: T,
        style: { outline: "none" }
      },
      E && /* @__PURE__ */ t.createElement(
        E,
        {
          ...v,
          onCloseMenu: i
        }
      )
    )
  ));
};
export {
  Q as GridColumnMenuWrapper
};
